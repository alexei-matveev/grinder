## Clojure & Leiningen Wrapper

Leiningen project to handle The Grinder build, class path, and
uberjar build. Will hopefully remain a thin wrapper.

See [examples](https://github.com/locopati/load-testing-with-clojure)
of the Clojure scripts for the Grinder.  See also a
[Mavenized Grinder](https://github.com/gradeawarrior/mavenized-grinder).

## Usage

    lein run Console [-headless]
    lein run Grinder

The Clojure code merely invokes Java classes, either
[Console](../grinder-core/src/main/java/net/grinder/Console.java) or
[Grinder](../grinder-core/src/main/java/net/grinder/Grinder.java).

Console needs to be able to listen to a few ports. The Console listens
by default to 0.0.0.0:6372, this is where the agents will need to
[connect to](http://grinder.sourceforge.net/g3/getting-started.html). At
:6373 there is a REST endpoint of the
[Console service](http://grinder.sourceforge.net/g3/console-service.html)
which is, BTW, also a Clojue [subproject](../grinder-console-service).

## Building an Uberjar

There will be  a few issues when building the  Gringer as uberjar. The
known ones are discussen in the following subsections.

### Choosing the Grinder UI

By default the Grinder Console starts the Swing UI.

On a headless Linux VM `lein run Console` shows exception saying
DISPLAY is not set while `lein -jar ${uber}.jar Console` appears to
start the console (rest) service as if one specified `-headless`
option. Same behaviour is observed if you launch the
[class](../grinder-core/src/main/java/net/grinder/Console.java)
directly:

    java -classpath ${uber}.jar net.grinder.Console

On the other hand if you start it like this:

    java -classpath $(lein classpath) net.grinder.Console

or like this

    java -classpath $(lein classpath) grinder_clj.core Console

The Console would (try to) launch the Swing UI.  There is some
non-trivial logic of
[ConsoleFoundation](../grinder-core/src/main/java/net/grinder/console/ConsoleFoundation.java)
that "dynamically" loads UI versions and if nothing works falls back
to TextUI.

This logic appears to consult the class name in the Java resource
named:

    META-INF/net.grinder.console

and use that as the UI implementation. There appear to be at least two
implementations:

    net.grinder.console.swingui.ConsoleUI
    net.grinder.console.service.Bootstrap

listed respectively in two identically named resource files:

    ../grinder-swing-console/src/main/resources/META-INF/net.grinder.console
    ../grinder-console-service/resources/META-INF/net.grinder.console

The uberjar,  on the other hand,  will only contain one  resource file
named  like  that. It  happens  to  be the  Bootstrap  implementation,
possibly  unfinished.  If  you  edit the  uberjar  with vim  replacing
Bootstrap implementation with  the Swing UI, then  running the uberjar
as above does launch the Swing  UI.  To make that deterministic we put
a third identically named resource into

    ./resources/META-INF/net.grinder.console

choosing the Swing UI option.

### Instrumentation in Worker Processes

Another issue  with uberjar  is missing instrumentation  features. The
`grinder-dcr-agent`    artifact     appears    to    be     used    as
[Java Agent](https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html),
cf. the `MANIFEST.MF` content of the respective JAR file

    ...
    Premain-Class: net.grinder.util.weave.agent.ExposeInstrumentation
    Can-Redefine-Classes: true
    Can-Retransform-Classes: true
    ...

Also the Grinder  Agent prints the command line that  is used to start
the Worker  Process. Instrumentation is usually  achieved by supplying
the Java Agent flag:

    java -javaagent:grinder-dcr-agent-X.YZ.jar ...

The command line for the worker is generated by the Java Code in
[WorkerProcessCommandLine](../grinder-core/src/main/java/net/grinder/engine/agent/WorkerProcessCommandLine.java)
with the hardwired logic matching on the name of the
`grinder-dcr-agent` JAR in the, sigh.

As a  workaround we adapted the  [project.clj](project.clj) to augment
the uberjar manifest by the three lines above. But you will still need
to    adapt    the    variable    `grinder.jvm.arguments`    in    the
`grinder.properties`  used  by  the   Grinder  Agent  to  specify  the
`-javaagent:...`     flag.    The     hardwired    logic     in    the
WorkerProcessCommandLine will not figure it out.

## License

Copyright Â© 2017 Alexei Matveev <alexei.matveev@gmail.com>

Distributed under the Eclipse Public License either version 1.0 or (at
your option) any later version.
